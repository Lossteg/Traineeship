### Структура проекта и пояснение действий

```
├── .gitignore
├── README.md
├── Makefile
├── docker-compose.yml
├── docker
│   ├── nginx
│   │   ├── Dockerfile
│   │   └── default.conf
│   └── php
│       └── Dockerfile
└── app
    └── index.php
```
**В каталоге app содержится файл index.php со следующим содержимым будущей страницы:**
```php script
<?php
echo "Hello world";
```
**Каталог docker включает в себя два подкаталога:**
```
docker
├── nginx
└── php
```

**В подкаталоге php находится Dockerfile для создания образа php-alpine:**
```dockerfile
# Используем официальный образ PHP 8.2 с установленным FPM (FastCGI Process Manager) на базе Alpine Linux
FROM php:8.2-fpm-alpine

# Устанавливаем необходимые системные библиотеки через пакетный менеджер Alpine
RUN apk add --no-cache \
    libintl \               # Библиотека для работы с международными форматами
    icu-dev \               # Библиотека для работы с интернационализацией (используется расширением intl)
    libxml2-dev \           # Библиотека для работы с XML (нужна для некоторых PHP-расширений)
    postgresql-dev \        # Разработка для поддержки PostgreSQL (используется для pdo_pgsql)
    imagemagick-dev \       # Библиотека для работы с ImageMagick (нужна для обработки изображений)
    libpng-dev \            # Библиотека для работы с PNG (нужна для графического расширения GD)
    libjpeg-turbo-dev \     # Оптимизированная библиотека для работы с JPEG (нужна для GD)
    freetype-dev \          # Поддержка работы с шрифтами (используется для GD)
    linux-headers           # Заголовки ядра Linux, нужны для сборки некоторых расширений

# Устанавливаем и активируем необходимые PHP-расширения
RUN docker-php-ext-install \
    intl \                  # Расширение для работы с интернационализацией (работает с ICU)
    bcmath \                # Расширение для работы с точными вычислениями с плавающей запятой
    opcache \               # Расширение для кеширования байт-кода PHP для ускорения работы
    pdo_pgsql \             # Расширение для работы с базой данных PostgreSQL через PDO
    gd                      # Расширение для работы с графикой (поддержка JPEG, PNG, шрифтов)

# Устанавливаем Imagick и Xdebug через PECL, а затем удаляем временные зависимости
RUN apk add --no-cache --virtual .build-deps $PHPIZE_DEPS \  # Устанавливаем зависимости для сборки PHP-расширений
    && pecl install imagick \                               # Устанавливаем Imagick через PECL (расширение для работы с изображениями)
    && docker-php-ext-enable imagick \                      # Активируем Imagick
    && apk del .build-deps                                  # Удаляем временные зависимости для очистки образа

# Аналогично устанавливаем Xdebug для отладки PHP-кода
RUN apk add --no-cache --virtual .build-deps $PHPIZE_DEPS \  # Устанавливаем зависимости для сборки
    && pecl install xdebug \                                # Устанавливаем Xdebug через PECL (для отладки PHP-кода)
    && docker-php-ext-enable xdebug \                       # Активируем Xdebug
    && apk del .build-deps                                  # Удаляем временные зависимости для уменьшения размера образа

# Устанавливаем Composer (менеджер зависимостей для PHP)
RUN curl -sS https://getcomposer.org/installer | php -- --install-dir=/usr/local/bin --filename=composer

# Устанавливаем рабочую директорию для проекта
WORKDIR /var/www

# Очищаем кэш и временные файлы для уменьшения размера Docker-образа
RUN rm -rf /var/cache/apk/* && \
    rm -rf /tmp/*

# Указываем, что контейнер должен запускать PHP-FPM при старте
CMD ["php-fpm"]
```

- **Imagick** и **Xdebug** не входят в базовую поставку PHP, их нужно отдельно устанавливать. PECL предоставляет механизм для установки таких дополнительных PHP-расширений, которые не являются частью стандартных модулей PHP.
- **Composer** — это инструмент для управления зависимостями в PHP, но его нет в официальных репозиториях пакетов большинства операционных систем, включая Alpine Linux (который используется в Docker-образе).
- **cURL (client URL)** — это инструмент, который позволяет скачивать данные из интернета через командную строку. В нашем случае, cURL нужен, чтобы загрузить установочный скрипт Composer с его официального сайта. Это быстрый и удобный способ получить последнюю версию Composer напрямую, особенно когда в системе нет встроенных инструментов для этого, как в нашем Docker-образе.

**Подкаталог nginx содержит два файла: Dockerfile для создания образа nginx и файл default.conf для настройки веб-сервера.**
Dockerfile:
```dockerfile
# Используем официальный образ Nginx версии 1.27.2 на базе Alpine Linux
FROM nginx:1.27.2-alpine

# Копируем файл конфигурации Nginx из локальной директории в контейнер
# Эта команда позволяет заменить стандартную конфигурацию Nginx своей, настроенной под конкретные требования приложения.
COPY ./default.conf /etc/nginx/conf.d/default.conf
```

- **/etc/nginx/conf.d/** — это директория, где Nginx хранит свои конфигурационные файлы. Файл default.conf содержит настройки, которые Nginx будет использовать для обработки запросов (например, маршрутизацию, указание корневого каталога для статических файлов, настройки SSL и т.д.). 

**Файл настройки nginx имеет следующую структуру:**
```shell script
server {
    # Указываем, что сервер будет слушать HTTP-запросы на порту 80
    listen 80;

    # Определяем серверное имя (доменное имя) для этого сервера
    server_name localhost;

    # Указываем корневую директорию, где находятся файлы приложения
    root /var/www/app;

    # Устанавливаем список файлов, которые будут использоваться по умолчанию при обращении к директории
    index index.php index.html;

    # Конфигурация для обработки запросов к корню сайта "/"
    location / {
        # Пытаемся найти файл или директорию по запрашиваемому URI
        # Если не найдено, возвращаем ошибку 404 (страница не найдена)
        try_files $uri $uri/ =404;
    }

    # Обрабатываем все запросы к файлам с расширением .php
    location ~ \.php$ {
        # Включаем стандартные параметры для работы с FastCGI (используются для передачи данных между Nginx и PHP-FPM)
        include fastcgi_params;
        
        # Указываем Nginx, куда отправлять запросы PHP (здесь php:9000 — это ссылка на сервис PHP-FPM, работающий в другом контейнере, слушающем порт 9000)
        fastcgi_pass php:9000;
        
        # Указываем файл, который будет выполнен по умолчанию при запросе к директории с PHP-скриптом
        fastcgi_index index.php;
        
        # Указываем полный путь к PHP-скрипту, который будет выполнен
        # Здесь используется переменная $fastcgi_script_name для подстановки имени запрашиваемого PHP-файла
        fastcgi_param SCRIPT_FILENAME /var/www/app/$fastcgi_script_name;
    }

    # Указываем, куда записывать логи ошибок
    error_log  /var/log/nginx/error.log;

    # Указываем, куда записывать логи успешных запросов (доступов)
    access_log /var/log/nginx/access.log;
}
```

**Наконец, объединяем образы php и nginx в единое окружение с помощью Docker Compose**
Структура docker-compose.yml файла:
```shell script
# Определение имени проекта через переменную окружения. COMPOSE_PROJECT_NAME можно задать в .env файле.
name: ${COMPOSE_PROJECT_NAME}

services:
  # Описание сервиса PHP
  php:
    # Указываем, что контейнер для PHP будет собираться из Dockerfile
    build:
      # Путь к директории с Dockerfile для PHP
      context: ./docker/php
    # Назначаем имя контейнеру, чтобы проще было к нему обращаться
    container_name: php
    # Монтируем локальную директорию с исходным кодом приложения в контейнер по указанному пути
    volumes:
      - ./app:/var/www/app
    # Подключаем контейнер к сети project-network для связи с другими контейнерами
    networks:
      - project-network
    # Запускаем контейнер от имени пользователя с UID 1000 и GID 1000 (обычно это соответствует текущему пользователю на хосте)
    user: 1000:1000

  # Описание сервиса Nginx
  nginx:
    # Nginx тоже будет собираться из Dockerfile
    build:
      # Путь к директории с Dockerfile для Nginx
      context: ./docker/nginx
    # Назначаем имя контейнеру Nginx
    container_name: nginx
    # Пробрасываем порт 80 на хост-машину, чтобы Nginx был доступен по локальному порту 80
    ports:
      - "80:80"
    # Монтируем директорию с приложением и директорию для логов Nginx
    volumes:
      - ./app:/var/www/app
      - nginx-logs:/var/log/nginx
    # Зависимость от сервиса php — Nginx будет запущен только после запуска PHP
    depends_on:
      - php
    # Подключаем Nginx к той же сети, что и PHP, чтобы они могли взаимодействовать
    networks:
      - project-network

  # Описание сервиса базы данных PostgreSQL
  db:
    # Используем официальный образ PostgreSQL с версией 17.0 на базе Alpine 3.20
    image: postgres:17.0-alpine3.20
    # Назначаем имя контейнеру PostgreSQL
    container_name: postgres
    # Задаём переменные окружения для настройки пользователя, пароля и базы данных. Значения берутся из .env файла.
    environment:
      POSTGRES_USER: ${POSTGRES_USER}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: ${POSTGRES_DB}
    # Монтируем директорию для хранения данных базы данных и логов на хост-машине
    volumes:
      - db-data:/var/lib/postgresql/data
      - db-logs:/var/log/postgresql
    # Подключаем базу данных к той же сети, что и другие сервисы
    networks:
      - project-network

# Определение томов для хранения данных и логов
volumes:
  # Том для хранения данных PostgreSQL (будет сохраняться на хосте)
  db-data:
  # Том для логов PostgreSQL
  db-logs:
  # Том для логов Nginx
  nginx-logs:

# Определение сети, которая связывает все контейнеры
networks:
  # Создаём пользовательскую сеть с драйвером "bridge"
  project-network:
    driver: bridge
```

**В данном файле встречаются переменные окружения, которые располагаются в файле .env на одном уровне с файлом конфигурации Docker Compose. Вот структура .env файла:**
```shell script
# Название проекта для Docker Compose
COMPOSE_PROJECT_NAME=my_project

# Настройки PostgreSQL
POSTGRES_USER=myuser        # Имя пользователя для базы данных
POSTGRES_PASSWORD=mypassword # Пароль для пользователя базы данных
POSTGRES_DB=mydatabase       # Имя базы данных
```

**Файл Makefile был создан для упрощения работы с проектом, который использует Docker Compose.** Он определяет несколько часто используемых команд для управления контейнерами, таких как установка, запуск, остановка и подключение к контейнеру PHP, чтобы пользователю не приходилось вручную вводить длинные команды. Вместо этого можно выполнять короткие команды make install, make start, и так далее.
Структура Makefile:
```makefile
# Определяем переменную, которая указывает на файл конфигурации Docker Compose
DOCKER_COMPOSE_FILE := ./docker-compose.yml

# Цель для установки и запуска всех сервисов в фоне после сборки
install:
        # Выполняем команду docker compose с указанным файлом, собираем и запускаем контейнеры в фоновом режиме
        docker compose -f $(DOCKER_COMPOSE_FILE) up --build -d

# Цель для запуска уже собранных контейнеров в фоновом режиме
start:
        # Запускаем контейнеры в фоновом режиме
        docker compose -f $(DOCKER_COMPOSE_FILE) up -d

# Цель для остановки и удаления всех контейнеров, сетей и томов, созданных Docker Compose
stop:
        # Останавливаем и удаляем все контейнеры, сети и тома, созданные с помощью Docker Compose
        docker compose -f $(DOCKER_COMPOSE_FILE) down

# Вход в контейнер PHP в интерактивном режиме
terminal:
        # Открываем интерактивную оболочку внутри запущенного контейнера PHP
        docker compose -f $(DOCKER_COMPOSE_FILE) exec php sh

# Правило .PHONY для обозначения целей, не являющихся файлами
.PHONY: install start stop terminal
```
- **.PHONY** в Makefile используется для определения целей, которые не связаны с файлами. Обычно, make проверяет наличие файла с именем цели и, если такой файл существует, make может считать цель выполненной. Это может привести к проблемам, если вы ожидаете выполнения определенной команды, но make считает, что цель уже выполнена, поскольку файл с таким именем существует. Объявление цели как .PHONY гарантирует, что команды, связанные с этой целью, будут выполняться каждый раз, когда вы вызываете make, независимо от существования файлов с такими именами. Таким образом, .PHONY используется для обеспечения правильного выполнения команд, которые не должны зависеть от состояния файловой системы.
